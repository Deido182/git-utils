#!/usr/bin/env bash

. "$( cd -- "$( dirname -- "${BASH_SOURCE[0]:-$0}" )" &> /dev/null && pwd )/../container-context/commands/libs/common-functions-and-constants"

REPO_DIR="$(git rev-parse --show-toplevel)"
REPO_NAME="$(basename ${REPO_DIR})"
CONTAINER_BASENAME="git-commands-container"
CONTAINER_NAME="${CONTAINER_BASENAME}-${REPO_NAME}"
CONTAINER_IMAGE_TAG="${CONTAINER_BASENAME}-image"
CONTAINER_SETUP_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]:-$0}" )" &> /dev/null && pwd )"
CONTAINER_CONTEXT="${CONTAINER_SETUP_DIR}/../container-context"

# "--cache-from" used like this should be the default, anyway
docker build \
	--cache-from "${CONTAINER_IMAGE_TAG}" \
	--tag "${CONTAINER_IMAGE_TAG}" \
	--build-arg EMAIL="$(git config --get user.email)" \
	--build-arg NAME="$(git config --get user.name)" \
	"${CONTAINER_CONTEXT}" >/dev/null 2>&1

if [[ $? != 0 ]]; then
	echo "ERROR: 'docker build' failed"
	exit 1
fi

yes | docker image prune >/dev/null 2>&1 & # Remove dangling images; no need to wait for it

serialize() {
	params=("$@")
	local out="${params[0]}"
	for i in $(seq 1 1 $((${#params[@]}-1))); do
		if [[ "${params[i]}" == *[[:space:]]* || "${params[i]}" == "" ]]; then
			out="${out} \"${params[i]}\""
		else 
			out="${out} ${params[i]}"
		fi
	done
	echo "${out}"
}

serialized_params="$(serialize "$@")"

# tmp_dir shared to make it testable through mocked repos on host file uri (file://)
# Not that good, I agree
docker run \
	--rm \
	--name="${CONTAINER_NAME}" \
	--volume="${REPO_DIR}:/repo" \
	--volume="${tmp_dir}:${tmp_dir}" \
	"${CONTAINER_IMAGE_TAG}" \
	ssh-agent bash -c "ssh-add /root/.ssh/private_key.*; ${serialized_params}"
