#!/bin/bash

while getopts "m:r:w:p:" opt; do
  case "${opt}" in
  m) export new_message="${OPTARG}" ;;
  r) export replace="${OPTARG}" ;; # As basic regex
  p) export replace="^" ;& # Fall-through
  w) export with="${OPTARG}" ;;
  esac
done
shift $((OPTIND - 1))

. "$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )/libs/common-functions-and-constants"

export ref="$(git rev-parse $1)"

if [[ -v new_message ]] && [[ -v replace ]]; then
  print_error "Both -m and -r (or -p) options are present"
  exit 1
fi

if [[ -v replace ]]; then
  require_confirmation "Going to perform the replacement on several commits (from '${ref}' on)"
  if [[ $? != 0 ]]; then
    print_error "Replacement aborted"
    exit 1
  fi
fi

commit_new_message() {
  local curr="$(git rev-parse HEAD)"
  if [[ -v replace ]]; then 
    new_message="$(git show --pretty=format:"%B" --no-patch ${curr} | sed 's|'"${replace}"'|'"${with}"'|g')"
  fi
  if [[ "${curr}" == "${ref}" ]] || [[ -v replace ]]; then 
    git commit --amend --allow-empty --no-edit -m "${new_message}"
  fi
}

printf -v serialized_fun '%q ' "$(declare -f commit_new_message); commit_new_message"
export serialized_fun

git rebase --keep-empty --rebase-merges "${ref}^" \
	--exec 'bash -c "eval ${serialized_fun}"'
