#!/bin/bash

while getopts "m:r:w:p:" opt; do
  case "${opt}" in
  m) export new_message="${OPTARG}" ;;
  r) export replace="${OPTARG}" ;; # As basic regex
  p) export replace="^" ;& # Fall-through
  w) export with="${OPTARG}" ;;
  esac
done
shift $((OPTIND - 1))

if [[ -v new_message ]] && [[ -v replace ]]; then
  print_error "Both -m and -r (or -p) options are present"
  exit 1
fi

. "$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )/libs/common-functions-and-constants"

sort_array() {
  IFS=$'\n' out=($(sort <<< "$*"))
  unset IFS
  echo ${out[@]}
}

drop_duplicates() {
  local input=($(sort_array $@))
  local out=("${input[0]}")
  for i in $(seq 1 1 $((${#input[@]}-1))); do
    if [[ "${input[i]}" == "${input[i-1]}" ]]; then
      continue
    fi
    out+=("${input[i]}")
  done
  echo ${out[@]}
}

index_of() {
  local arr=(${@:1:$#-1})
  shift $(($#-1))
  local el=$1
  for i in $(seq 0 1 $((${#arr[@]}-1))); do
    if [[ "${el}" == "${arr[i]}" ]]; then
      echo $i
      return 0
    fi
  done
  echo -1
}

raw_refs=$@
rev_list=($(git rev-list HEAD))
indexes=()

for ref in ${raw_refs[@]}; do
  toks=()
  split "${ref}" ".." toks
  index0=$(index_of ${rev_list[@]} "$(git rev-parse ${toks[0]})")
  if [[ ${#toks[@]} > 1 ]]; then
    index1=$(index_of ${rev_list[@]} "$(git rev-parse ${toks[1]})")
  fi
  if [[ -v index1 && index0 != index1 ]]; then
    if [[ ${index0} < ${index1} ]]; then
      print_error "'${ref}' is not a valid range"
      exit 1
    fi
    indexes+=($(seq ${index1} 1 $((${index0}-1))))
    unset index1
  fi
  indexes+=(${index0})
done

indexes=($(drop_duplicates ${indexes[@]} | sort -n))

commit_new_message() {
  local curr="$(git rev-parse HEAD)"
  if [[ "${curr}" == "${ref}" ]]; then 
    if [[ -v replace ]]; then 
      new_message="$(git show --pretty=format:"%B" --no-patch ${curr} | sed 's|'"${replace}"'|'"${with}"'|g')"
    fi
    git commit --amend --allow-empty --no-edit -m "${new_message}"
  fi
}

printf -v serialized_fun '%q ' "$(declare -f commit_new_message); commit_new_message"
export serialized_fun

for i in ${indexes[@]}; do
  export ref="${rev_list[i]}"
  git rebase --keep-empty --rebase-merges "${ref}^" \
	  --exec 'bash -c "eval ${serialized_fun}"'
done
