#!/usr/bin/env bash

tmp_dir="/tmp/git-utils"
installed_commands_basename=installed-commands
red_text='\033[0;31m'
green_text='\033[0;32m'
yellow_text='\033[0;33m'
default_text='\033[0m'

print_coloured() {
	echo -e "$1$2"
}

print_warning() {
	print_coloured "${yellow_text}" "WARNING: $1"
}

print_error() {
	print_coloured "${red_text}" "ERROR: $1"
}

print_success() {
	print_coloured "${green_text}" "$1"
}

remove_repo() {
    if [ -d "$1" ]; then
        yes | rm -r $1
    fi
}

create_repo() {
    git config --local user.name "$2"
    git config --local user.email "$3"
    remove_repo $1
    mkdir -p $1 &&
        cd $1 &&
        git init &&
        git commit -m "initial commit" --allow-empty # Necessary for HEAD
    if [[ "$(git rev-parse --abbrev-ref HEAD)" != "master" ]]; then
      git branch -m master
    fi
}

# Simply 'echo' an array would not work, due to possible spaces in elements

split() {
    local str="$1"
    local sep="$2"
    # To prevent circular reference
    local -n _split_fun_input=$3
    local first_in=1
    for i in $(seq ${#sep} 1 ${#str}); do
        local last_in=$((${i}-${#sep}))
        if [[ "$(expr substr "${str}" $((${last_in}+1)) ${#sep})" == "${sep}" ]]; then
            _split_fun_input+=("$(expr substr "${str}" ${first_in} $((${last_in}-${first_in}+1)))")
            first_in=$((${i}+1))
        fi
    done
    if [[ ${first_in} != $((${#str}+1)) ]]; then
        _split_fun_input+=("$(expr substr "${str}" ${first_in} $((${#str}-${first_in}+1)))")
    fi
}

require_confirmation() {
    echo "$1"
    echo "Do you want to continue?"
    select yn in "Yes" "No"; do
        case $yn in
            Yes ) return 0 ;;
            No ) return 1 ;;
        esac
    done
}

# In-place
sort_array() {
  # TODO: add -n option
  # To prevent circular reference
  local -n _sort_array_fun_input=$1
  IFS=$'\n' _sort_array_fun_input=($(sort <<< "${_sort_array_fun_input[*]}"))
  unset IFS
}

clone_into() {
  # To prevent circular reference
  local -n _clone_into_fun_input=$1
  local -n _clone_into_fun_output=$2
  IFS=$'\n' _clone_into_fun_output=($(printf '%s\n' "${_clone_into_fun_input[@]}"))
  unset IFS
}

# In-place
drop_duplicates() {
  # To prevent circular reference
  local -n _drop_duplicates_fun_input=$1
  sort_array _drop_duplicates_fun_input
  local out=("${_drop_duplicates_fun_input[0]}")
  for i in $(seq 1 1 $((${#_drop_duplicates_fun_input[@]}-1))); do
    if [[ "${_drop_duplicates_fun_input[i]}" == "${_drop_duplicates_fun_input[i-1]}" ]]; then
      continue
    fi
    out+=("${_drop_duplicates_fun_input[i]}")
  done
  clone_into out _drop_duplicates_fun_input
}

index_of() {
  # To prevent circular reference
  local -n _index_of_fun_input=$1
  local el="$2"
  for i in $(seq 0 1 $((${#_index_of_fun_input[@]}-1))); do
    if [[ "${el}" == "${_index_of_fun_input[i]}" ]]; then
      echo $i
      return 0
    fi
  done
  echo -1
}
